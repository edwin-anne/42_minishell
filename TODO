MINISHELL:     
1. EXECUTING (Lola):
    
    handling builtins cmds:
    ✔ echo with the option -n @done(25-03-11 17:17)
        ✔ echo multiple arg no space between arg @done(25-03-22 17:38)
      ✔ cd with only a relative or abs path @done(25-03-22 17:38)
      ✔ pwd with no option (verif s'il se sert de l'env) @done(25-03-13 18:39)
      ✔ export with no option @done(25-03-08 15:06)
      ✔ unset with no options @done(25-03-09 16:11)
      ✔ env with no options or arguments @done(25-03-10 17:53) 
          ✔ env s'exec dans l'enfant @done(25-04-05 13:22)
      ✔ echo -n -n (ne doit rien écrire) @done(25-03-22 12:18)
      ✔ exit with no options @done(25-03-17 11:34)

    tofix:
        ✔ test: "export =" -> segfault (check après merge) @done(25-04-07 18:20)
        ✔ test: echo -nnnnnnnnn -> doit fonctionner @done(25-04-05 13:35)
        ✔ test: "ls | ls" -> actuellement exec 4 fois ls au lieu de 2 @done(25-04-05 13:22)
        ☐ test: "cd .." -> ne fonctionne pas. 
        ☐ test: "cd" -> ne renvoie pas vers le home
        ☐ test: "cd <dossier qui n'existe pas>" doit renvoyer une erreur
        ☐ fix: (child.c:64) appelle de shell->cmds ? (pas cmds)
        ☐ fix: manage command not found "execve failed: Bad address"
        ☐ fix: verification que le fd ne soit pas a -1 avant d'ouvrir "Warning: invalid file descriptor -1 in syscall close()"
        ☐ fix: "exit" tout seul fait -> "Syscall param exit_group(status) contains uninitialised byte(s)"
        ☐ fix: wait_children est appeler si c'est une commande builtins parent

2. PARSING (Edwin) :
    parsing error:
        ✔ prendre en consideration le "&&" comme un argument de la commande @done(25-04-15 12:00)
        ☐ emmetre l'exit code quand "echo $?" (fait a tester !)
        ✔ mettre les here_doc dans le dossier /tmp au lieu de la racine projet @done(25-04-16 11:41)
        ✔ here_doc ??? "free(): double free detected in tcache 2" @done(25-04-16 11:41)
        ☐ echo 'Hello $USER' ne doit pas remplacer la valeur $USER
        ☐ "tr ' ' '\n'" parsing mauvais = "tr" "'" "'" "'\n'"
        ☐ "ls |" - "ls | | | grep test" seg fault
        ☐ ls | echo "oui" > ne supprime pas les quotes inutile

3. ERREUR INCONNU :
    ☐ "echo "line1\nline2\nline3" | grep line | wc -l" renvoie 1 alors qu'il doit renvoyer 3

/*TODO : executing checklist (in child)
    
check where to redirect the entry and if we need, redirect the output
If we have an here_doc do it first
if we have multiple here_doc we need to stock them then erase it with the next here_doc
! ulimit -n (if we open to much fd)? open file/pipe in the child dynamicly
find path to cmd and execve
do it for every pipe/cmd
!! handle exit code !

    todo 2 : if we have only one cmd (no pipe)
    
redirecting then check if we have a builtins (for the parent)? if not a builtins then fork, redirect the child output/entry and execve

    todo 3 : multiple cmd (1 or + pipes)
    ! if we have a builtin like cd it don't work because it change the PWD and OLDPWD of the CHILD not the main
    ? pipex but mine need some modifications (creation of pipes and structs etc)
    ? pipex need to be executed from left to right (changing one while when creating my lst of cmd)
todo : redirection
    
redirect the STDIN to the last IN or HDC redirection (before the pipe)
if we don't have the permission on the infile the command isn't exec and the outfile isn't created if it doesn't exist! even if we don't have the perms we do every here_doc before exit/quit
finally we redirect the STDOUT to the last OUT or APP and create it if it doesn't exist
! don't forget to unlink the tmp file of each heredoc before killing the child? redirection with pipes ? boolean for handle_out to see if we find a out or not

    todo 3.1 : pipes
    
ulimit -n change the limit for both but they are separate for example :
ulimit -n 25 set the limit to 25 so the main can open 25 fd and the child can open 25 fd too
if the main open a fd (24 left) the child still have 25 left
? so to handle it maybe we can create each pipe in the child before the redirection

todo 4 : cmd 
check path for every command with access and our envp list
! if no path execve wil "fail" and so we need to free evrything
execve*/